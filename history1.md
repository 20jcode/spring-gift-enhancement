# step1

카테고리 필수 조건

- 상품은 항상 하나의 카테고리가 있어야 한다.
- 상품 카테고리는 수정할 수 있다.
- 관리자 화면에서 상품을 추가할 때 카테고리를 지정할 수 있다.
- 상품 추가 시 카테고리를 지정하지 않으면 안되도록 한다.

## 로그

response에서 ResponseEntity를 사용해서 해보도록 하자 + 나중에 전부 수정해주자.

EntityModel -> spring hateoas 이용시 (하이퍼 미디어 규약?)

service 부분이 없어서 그런가 Mock가 제대로 설정되지 않는다.

mappedBy -> 엔티티 class 이름을 적어야함.

---
product에 카테고리를 연결시켜야함.

그럼 관련된 모든 부분이 변경되어야하는?

product의 컨트롤러와 서비스와 테스트코드까지 전부 변경을 해주어야하는가? 아니면, 

---

서비스에서 해당 부분을 추가적으로 넣어주도록 동작을 시키면 기존의 코드를 건드리지않고 할 수 있다고 생각된다.



### 의문

1. post, put에 대해 성공적으로 200을 반환해야한다면, 컨트롤러는 void 여야하는가? 아니면, ResponseEntity로 명시적?

명시적으로 하는 것이 좋다고 생각되어짐. 특정 상황에서는 POST에 대해 처리가 불가능할 수 있기 때문.

2. 200만 반환하고 싶다면, ResponseEntity 로 원시타입을 그대로 사용하여도 되는가? 에 대해

https://vesselsdiary.tistory.com/137

post, put 등에서 반환에서 특정 url로 location header를 변경해서 넘겨주기?

3. 서비스가 다른 서비스로 작업을 넘겨도 되는가?

여러 서비스를 모아서 처리하는 서비스도 있을 수 있지 않을까?

4. 커스텀 Exception을 만들었을 때 ( ex -> MemberNoSuchException.class ) 더 이상 상속된 클래스가 필요없다면
final class로 하는 것이 이점이 있는가?



### 리팩토링 예약

- 서비스에 기본적인 CRUD 이름 통일하기

- DTO 이름 Request / Response 로 통일해주기

- 컨트롤러 메소드 이름 통일하기

- post, put에 대한 관리 : post는 생성, put은 일종의 업데이트로 생각하자.

- post, put에 대해 반환타입 -> 기본 200, 추가 전송 데이터 있으면 204, ResponseEntity 명시적 사용

- 컨트롤러에 대해서 Mock 객체를 활용한 테스트를 만들어보자.

- ~~product update를 jpa save로 변환하기~~
  (jpa에서 id값이 null이 아니면 이미 존재한다고 판단하고 merge 한다.)

- 페이징 - 사용자가 정렬 옵션이나 페이지 사이즈 등의 옵션을 넘길 수 있도록 하기

- ~~예외에 대해서 구조화하기 -> 예외 기본 생성자 private으로 하거나, 기본 예외 메세지와 httpstate를 만들어주기~~

- ~~예외에 대해서 중복된 구조 상속 이용?~~
